from typing import TYPE_CHECKING

from django.core.exceptions import FieldError
from django.db.models import Lookup, fields as django_fields

from .validators import validate_dn

if TYPE_CHECKING:
    from .backends.ldap.base import DatabaseWrapper


class LDAPField(django_fields.Field):
    binary_field: bool = False
    multi_valued_field: bool = False
    ordering_rule: str | None = None

    def __init__(
        self,
        *args,
        ordering_rule: str | None = None,
        hidden: bool = False,
        multi_valued_field: bool | None = None,
        **kwargs,
    ):
        """
        :param args:
        :param ordering_rule: Override the LDAP ordering rule for this field.
                              The fields provided by django-ldapdb already have the correct ordering rules set.
        :param hidden: Hide this field from all autogenerated forms and admin interfaces.
        :param kwargs:
        """
        super().__init__(*args, **kwargs)
        if hidden is not None:
            self.hidden = hidden

        if multi_valued_field is not None:
            self.multi_valued_field = multi_valued_field

        if ordering_rule is not None:
            self.ordering_rule = ordering_rule

    def from_db_value(self, value, expression, connection):  # noqa: ARG002
        if value is None:
            if self.null:
                return value
            elif self.multi_valued_field:
                return []
            elif self.binary_field:
                return b'' if self.binary_field else ''

        if not isinstance(value, list | tuple):
            value = [value]

        if self.binary_field:
            return value if self.multi_valued_field else value[0]

        decoded_vals = [
            v.decode(connection.charset) if isinstance(v, bytes | bytearray) else v
            for v in value
        ]
        return decoded_vals if self.multi_valued_field else decoded_vals[0]

    def run_validators(self, value):
        """
        Override run_validators to make sure we validate individual values if this is a multi_valued_field.
        """
        if self.multi_valued_field and isinstance(value, list):
            for v in value:
                super().run_validators(v)
        else:
            super().run_validators(value)

    def get_db_prep_value(self, value, *_args, prepared=False, **_kwargs):
        """Prepare a value for DB interaction.

        Returns:
        - list(bytes) if not prepared
        - list(str) if prepared
        """
        if prepared:
            return value

        if value is None:
            return []

        values = value if self.multi_valued_field else [value]
        prepared_values = [self.get_prep_value(v) for v in values]

        # Remove duplicates.
        # https://tools.ietf.org/html/rfc4511#section-4.1.7 :
        # "The set of attribute values is unordered."
        # We keep those values sorted in natural order to avoid useless
        # updates to the LDAP server.
        return sorted({v for v in prepared_values if v})

    def get_db_prep_save(self, value, connection: 'DatabaseWrapper'):
        values = self.get_db_prep_value(value, connection, prepared=False)
        if self.binary_field:
            # Already raw values; don't encode it twice.
            return values
        else:
            return [v.encode() for v in values]


class CharField(django_fields.CharField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'max_length': 200}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None if self.null else ''
        return value


class TextField(CharField):
    pass  # just the same thing as CharField in LDAP


class DistinguishedNameField(CharField):
    default_validators = [validate_dn]


class PrimaryDistinguishedNameField(DistinguishedNameField):
    _allowed_lookups = {"exact", "iexact"}

    def get_lookup(self, lookup_name: str) -> Lookup:
        if lookup_name not in self._allowed_lookups:
            raise FieldError(
                f'Lookup {lookup_name} is not supported for DN fields. '
                'Either use an exact lookup filter(dn=...), '
                'iterate over the list yourself or add another field for something like openLDAPs entryDN attribute'
            )
        return super().get_lookup(lookup_name)


class BinaryField(django_fields.BinaryField, LDAPField):
    binary_field = True

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None if self.null else b''
        return value


class BooleanField(django_fields.BooleanField, LDAPField):
    """
    LDAP stores boolean values as 'TRUE' and 'FALSE'.
    Returns True if field is 'TRUE', None if field.null=True and 'FALSE' otherwise.
    Default value is None if field.null=True but can be overridden by setting default=True or False.
    """

    def from_db_value(self, value, expression, connection):
        raw = super().from_db_value(value, expression, connection)
        if raw in (None, ""):
            return None
        return str(raw).upper() == "TRUE"

    def get_prep_value(self, value):
        if value is None:
            return None
        return "TRUE" if value else "FALSE"


class EmailField(django_fields.EmailField, CharField):
    pass


class IntegerField(django_fields.IntegerField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'null': True}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return value
        return int(value)


class MemberField(DistinguishedNameField):
    multi_valued_field = True


class DateField(django_fields.DateField):
    def __init__(self, *args, fmt='%Y-%m-%d', **kwargs):
        self.date_format = fmt
        super().__init__(*args, **kwargs)

import enum
import re
from datetime import date, datetime, timedelta, timezone
from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable
from zoneinfo import ZoneInfo

from django.core.exceptions import FieldError
from django.db.models import Lookup, fields as django_fields
from django.utils.timezone import is_naive

from ldapdb.validators import validate_dn

if TYPE_CHECKING:
    from ldapdb.backends.ldap.base import DatabaseWrapper


class UpdateStrategy(str, enum.Enum):
    ADD_DELETE = 'ADD_DELETE'  # multi (MOD_ADD + MOD_DELETE)
    REPLACE = 'REPLACE'  # single (MOD_REPLACE)


@runtime_checkable
class RenderLookupProtocol(Protocol):
    def render_lookup(self, field_name: str, lookup_name: str, value: Any) -> str | None:
        """Convert the value passed to the QuerySet filter to an LDAP filter string."""


class LDAPField(django_fields.Field, RenderLookupProtocol):
    binary_field: bool = False
    multi_valued_field: bool = False
    ordering_rule: str | None = None
    update_strategy: UpdateStrategy = UpdateStrategy.REPLACE
    read_only: bool = False

    def __init__(
        self,
        *args,
        ordering_rule: str | None = None,
        hidden: bool = False,
        multi_valued_field: bool | None = None,
        update_strategy: UpdateStrategy | None = None,
        read_only: bool | None = None,
        **kwargs,
    ):
        """
        :param args:
        :param ordering_rule: Override the LDAP ordering rule for this field.
                              The fields provided by django-ldapdb already have the correct ordering rules set.
        :param hidden: Hide this field from all autogenerated forms and admin interfaces.
        :param kwargs:
        """
        super().__init__(*args, **kwargs)

        if not kwargs.get('db_column'):
            raise ValueError(f'{self.__class__.__name__} needs an explicit db_column argument')

        if hidden is not None:
            self.hidden = hidden

        if multi_valued_field is not None:
            self.multi_valued_field = multi_valued_field

        if ordering_rule is not None:
            self.ordering_rule = ordering_rule

        if update_strategy is not None:
            self.update_strategy = update_strategy

        # If read_only not explicitly provided, infer it from editable=False
        # (Django's editable=False affects forms/admin only. Let's keep this behaviour as-is).
        if read_only:
            self.blank = True
            self.null = True
            self.read_only = read_only

    def from_db_value(self, value, expression, connection):  # noqa: ARG002
        if value is None:
            if self.null:
                return value
            elif self.multi_valued_field:
                return []
            elif self.binary_field:
                return b'' if self.binary_field else ''

        if not isinstance(value, list | tuple):
            value = [value]

        if self.binary_field:
            return value if self.multi_valued_field else value[0]

        decoded_vals = [v.decode(connection.charset) if isinstance(v, bytes | bytearray) else v for v in value]
        return decoded_vals if self.multi_valued_field else decoded_vals[0]

    def run_validators(self, value):
        """
        Override run_validators to make sure we validate individual values if this is a multi_valued_field.
        """
        if self.multi_valued_field and isinstance(value, list):
            for v in value:
                super().run_validators(v)
        else:
            super().run_validators(value)

    def get_db_prep_value(self, value: Any, connection: 'DatabaseWrapper', prepared: bool = False):  # noqa: ARG002
        """Prepare a value for DB interaction.

        Returns:
        - list(bytes) if not prepared
        - list(str) if prepared
        """

        if self.read_only:
            has_value = bool(value) and value != [] if self.multi_valued_field else value not in (None, '', b'')
            if has_value:
                raise FieldError(
                    f'Field "{self.name}" (LDAP attribute "{self.db_column}") is read-only and cannot be written.'
                )
            # Make sure this attribute is not included in write operations
            return [] if not self.binary_field else []

        if prepared:
            return value

        if value is None:
            return []

        values = value if self.multi_valued_field else [value]
        prepared_values = [self.get_prep_value(v) for v in values]

        # Remove duplicates.
        # https://tools.ietf.org/html/rfc4511#section-4.1.7 :
        # "The set of attribute values is unordered."
        # We keep those values sorted in natural order to avoid useless
        # updates to the LDAP server.
        return sorted({v for v in prepared_values if v})

    def get_db_prep_save(self, value, connection: 'DatabaseWrapper'):
        values = self.get_db_prep_value(value, connection, prepared=False)
        if self.binary_field:
            # Already raw values; don't encode it twice.
            return values
        else:
            return [str(v).encode() for v in values]


class CharField(django_fields.CharField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'max_length': 200}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None if self.null else ''
        return value


class TextField(CharField):
    pass  # just the same thing as CharField in LDAP


class DistinguishedNameField(CharField):
    default_validators = [validate_dn]


class PrimaryDistinguishedNameField(DistinguishedNameField):
    _allowed_lookups = {'exact', 'iexact'}

    def get_lookup(self, lookup_name: str) -> Lookup:
        if lookup_name not in self._allowed_lookups:
            raise FieldError(
                f'Lookup {lookup_name} is not supported for DN fields. '
                'Either use an exact lookup filter(dn=...), '
                'iterate over the list yourself or add another field for something like openLDAPs entryDN attribute'
            )
        return super().get_lookup(lookup_name)


class BinaryField(django_fields.BinaryField, LDAPField):
    binary_field = True


class BooleanField(django_fields.BooleanField, LDAPField):
    """
    LDAP stores boolean values as 'TRUE' and 'FALSE'.
    Returns True if field is 'TRUE', None if field.null=True and 'FALSE' otherwise.
    Default value is None if field.null=True but can be overridden by setting default=True or False.
    """

    def from_db_value(self, value, expression, connection):
        raw = super().from_db_value(value, expression, connection)
        if raw in (None, ''):
            return None
        return str(raw).upper() == 'TRUE'

    def get_prep_value(self, value):
        if value is None:
            return None
        return 'TRUE' if value else 'FALSE'


class EmailField(django_fields.EmailField, CharField):
    pass


class IntegerField(django_fields.IntegerField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'null': True}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return value
        return int(value)


class MemberField(DistinguishedNameField):
    multi_valued_field = True
    update_strategy = UpdateStrategy.ADD_DELETE


_GTIME_RE = re.compile(
    r"""
    ^
    (?P<year>\d{4})
    (?P<mon>\d{2})?
    (?P<day>\d{2})?
    (?P<hour>\d{2})?
    (?P<minute>\d{2})?
    (?P<second>\d{2})?
    (?:\.(?P<frac>\d+))?          # fractional seconds
    (?P<tz>Z|[+\-]\d{4})?         # 'Z' or Â±HHMM
    $
    """,
    re.VERBOSE,
)


def parse_generalized_time(s: str) -> datetime:
    m = _GTIME_RE.match(s)
    if not m:
        raise ValueError(f'Invalid GeneralizedTime value: {s!r}')

    parts = {k: int(v) if v and k not in ['frac', 'tz'] else v for k, v in m.groupdict().items()}

    # Missing components default to minimal valid value (RFC says that is OK)
    dt = datetime(
        parts['year'],
        parts['mon'] or 1,
        parts['day'] or 1,
        parts['hour'] or 0,
        parts['minute'] or 0,
        parts['second'] or 0,
        int(float(f"0.{parts['frac']}") * 1_000_000) if parts['frac'] else 0,
    )

    tz = parts['tz']
    if tz == 'Z' or tz is None:
        dt = dt.replace(tzinfo=ZoneInfo('UTC'))
    else:
        sign = 1 if tz[0] == '+' else -1
        offset = (
            timedelta(
                hours=int(tz[1:3]),
                minutes=int(tz[3:5]),
            )
            * sign
        )
        dt = dt.replace(tzinfo=timezone(offset))
    return dt


def format_generalized_time(dt: date | datetime, include_tz: bool = False) -> str:
    if isinstance(dt, date) and not isinstance(dt, datetime):
        dt = datetime(year=dt.year, month=dt.month, day=dt.day)

    if dt.tzinfo is None:
        dt = dt.astimezone(ZoneInfo('UTC'))

    if include_tz:
        return dt.strftime('%Y%m%d%H%M%S%z')

    dt = dt.astimezone(ZoneInfo('UTC'))
    return dt.strftime('%Y%m%d%H%M%SZ')


class DateTimeField(LDAPField, django_fields.DateTimeField):
    default_date_format = '%Y-%m-%d %H:%M:%S %z'

    def __init__(self, *args, fmt: str | None = None, include_tz: bool = False, **kwargs):
        self.date_format = fmt or self.default_date_format
        self.include_tz = include_tz
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None

        dt = parse_generalized_time(value)
        return dt

    def get_prep_value(self, value: str | datetime) -> str | None:
        if value is None:
            return None

        if isinstance(value, str):
            value = datetime.strptime(value, self.date_format)

        if isinstance(value, datetime) and is_naive(value):
            value = value.replace(tzinfo=ZoneInfo('UTC'))

        value = format_generalized_time(value, include_tz=self.include_tz)
        return value


class DateField(DateTimeField, django_fields.DateField):
    default_date_format = '%Y-%m-%d'

    def __init__(self, *args, **kwargs):
        kwargs['include_tz'] = False
        super().__init__(*args, **kwargs)

    def from_db_value(self, *args, **kwargs):
        value: datetime = super().from_db_value(*args, **kwargs)
        if value is None:
            return None
        return value.date()

    def get_prep_value(self, value: str | date | datetime):
        if value is None:
            return None

        if isinstance(value, datetime):
            value = date(year=value.year, month=value.month, day=value.day)
        return super().get_prep_value(value)

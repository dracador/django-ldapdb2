import enum
import re
from datetime import date, datetime, timedelta, timezone
from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable
from zoneinfo import ZoneInfo

from django.core import checks
from django.core.exceptions import FieldError
from django.db.models import Lookup, fields as django_fields
from django.utils.timezone import is_naive

from ldapdb.validators import validate_dn

if TYPE_CHECKING:
    from ldapdb.backends.ldap.base import DatabaseWrapper


class UpdateStrategy(str, enum.Enum):
    ADD_DELETE = 'ADD_DELETE'  # multi (MOD_ADD + MOD_DELETE)
    REPLACE = 'REPLACE'  # single (MOD_REPLACE)


@runtime_checkable
class RenderLookupProtocol(Protocol):
    def render_lookup(self, field_name: str, lookup_name: str, value: Any) -> str | None:
        """Convert the value passed to the QuerySet filter to an LDAP filter string."""


class LDAPField(django_fields.Field, RenderLookupProtocol):
    apply_default_on_empty: bool = False
    binary_field: bool = False
    multi_valued_field: bool = False
    ordering_rule: str | None = None
    read_only: bool = False
    update_strategy: UpdateStrategy = UpdateStrategy.REPLACE

    def __init__(
        self,
        *args,
        ordering_rule: str | None = None,
        hidden: bool = False,
        multi_valued_field: bool | None = None,
        update_strategy: UpdateStrategy | None = None,
        read_only: bool | None = None,
        **kwargs,
    ):
        """
        :param args:
        :param ordering_rule: Override the LDAP ordering rule for this field.
                              The fields provided by django-ldapdb already have the correct ordering rules set.
        :param hidden: Hide this field from all autogenerated forms and admin interfaces.
        :param kwargs:
        """
        super().__init__(*args, **kwargs)

        if not kwargs.get('db_column'):
            raise ValueError(f'{self.__class__.__name__} needs an explicit db_column argument')

        if self.apply_default_on_empty and self.default:
            self.blank = True
            self.null = True

        if hidden is not None:
            self.hidden = hidden

        if multi_valued_field is not None:
            self.multi_valued_field = multi_valued_field

        if ordering_rule is not None:
            self.ordering_rule = ordering_rule

        if update_strategy is not None:
            self.update_strategy = update_strategy

        if read_only:
            self.blank = True
            self.null = True
            self.read_only = read_only

    def from_db_value(self, value, expression, connection):  # noqa: ARG002
        if value is None:
            if self.null:
                return value
            elif self.multi_valued_field:
                return []
            elif self.binary_field:
                return b'' if self.binary_field else ''

        if not isinstance(value, list | tuple):
            value = [value]

        if self.binary_field:
            return value if self.multi_valued_field else value[0]

        decoded_vals = [v.decode(connection.charset) if isinstance(v, bytes | bytearray) else v for v in value]
        return decoded_vals if self.multi_valued_field else decoded_vals[0]

    def _check_default(self, **_kwargs):
        if self.default is None and not self.null:
            return [
                checks.Error(
                    'no default value or null=True specified',
                    hint=(
                        'Set a default value or null=True.'
                        'Make sure your LDAP server allows for nonexistent member attributes'
                    ),
                    obj=self,
                    id='ldapdb.E001',
                )
            ]
        return []

    def check(self, **kwargs):
        errors = super().check(**kwargs)
        if self.apply_default_on_empty:
            errors.extend(self._check_default(**kwargs))
        return errors

    def clean(self, value, model_instance):
        """
        Convert the value's type and run validation. Validation errors
        from to_python() and validate() are propagated. Return the correct
        value if no error is raised.

        Override the default clean() method from Django to let validators run on individual values of
        multi-valued fields.
        """
        value = self.to_python(value)
        self.validate(value, model_instance)

        # Normalize once for multi-valued fields, then run validators per-element
        if self.multi_valued_field and not isinstance(value, list | tuple):
            value = [value]

        if self.multi_valued_field and isinstance(value, list | tuple):
            for v in value:
                self.run_validators(v)
        else:
            self.run_validators(value)
        return value

    def get_db_prep_value(self, value: Any, connection: 'DatabaseWrapper', prepared: bool = False):  # noqa: ARG002
        """Prepare a value for DB interaction.

        Returns:
        - list(bytes) if not prepared
        - list(str) if prepared
        """

        if self.read_only:
            if self.multi_valued_field:
                has_value = value not in (None, []) and bool(value)
            else:
                has_value = value not in (None, b'') if self.binary_field else value not in (None, '')
            if has_value:
                raise FieldError(
                    f'Field "{self.name}" (LDAP attribute "{self.db_column}") is read-only and cannot be written.'
                )
            # Make sure this attribute is not included in write operations
            return []

        if prepared:
            return value

        if value is None:
            values: list[Any] = []
        else:
            if self.multi_valued_field and not isinstance(value, list | tuple):
                value = [value]
            values = value if self.multi_valued_field else [value]

        prepared_values = [self.get_prep_value(v) for v in values]

        # Remove duplicates, discard falsy prepared values, sort for stable order.
        unique_values = sorted({v for v in prepared_values if v})

        # If nothing remains and the field opts in, apply the default (supports str or list defaults)
        if not unique_values and self.apply_default_on_empty and self.default:
            default_values = self.default if isinstance(self.default, list | tuple) else [self.default]
            prepared_defaults = [self.get_prep_value(v) for v in default_values]
            unique_values = sorted({v for v in prepared_defaults if v})

        return unique_values

    def get_db_prep_save(self, value, connection: 'DatabaseWrapper'):
        values = self.get_db_prep_value(value, connection, prepared=False)
        if self.binary_field:
            # Already raw values; don't encode it twice.
            return values
        else:
            return [str(v).encode() for v in values]


class CharField(django_fields.CharField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'max_length': 200}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None if self.null else ''
        return value

    def to_python(self, value):
        if value is None:
            return value

        if self.multi_valued_field:
            # Only return a list if the input is already a list/tuple
            if isinstance(value, list | tuple):
                return [str(v) for v in value]
            # For scalar inputs, return a scalar to avoid nested lists during DB prep
            return str(value)
        return str(value)


TextField = CharField


class DistinguishedNameField(CharField):
    default_validators = [validate_dn]


class PrimaryDistinguishedNameField(DistinguishedNameField):
    _allowed_lookups = {'exact', 'iexact'}

    def get_lookup(self, lookup_name: str) -> Lookup:
        if lookup_name not in self._allowed_lookups:
            raise FieldError(
                f'Lookup {lookup_name} is not supported for DN fields. '
                'Either use an exact lookup filter(dn=...), '
                'iterate over the list yourself or add another field for something like openLDAPs entryDN attribute'
            )
        return super().get_lookup(lookup_name)


class BinaryField(django_fields.BinaryField, LDAPField):
    binary_field = True


class BooleanField(django_fields.BooleanField, LDAPField):
    """
    LDAP stores boolean values as 'TRUE' and 'FALSE'.
    Returns True if field is 'TRUE', None if field.null=True and 'FALSE' otherwise.
    Default value is None if field.null=True but can be overridden by setting default=True or False.
    """

    def from_db_value(self, value, expression, connection):
        raw = super().from_db_value(value, expression, connection)
        if raw in (None, ''):
            return None
        return str(raw).upper() == 'TRUE'

    def get_prep_value(self, value):
        if value is None:
            return None
        return 'TRUE' if value else 'FALSE'


class EmailField(django_fields.EmailField, CharField):
    pass


class IntegerField(django_fields.IntegerField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'null': True}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return value
        return int(value)


class MemberField(DistinguishedNameField):
    # TODO: Maybe allow setting a QuerySet as a default?
    multi_valued_field = True
    update_strategy = UpdateStrategy.ADD_DELETE
    apply_default_on_empty = True

    # No custom get_db_prep_value needed; base class handles defaults.
    def from_db_value(self, value, expression, connection):
        """Convert DB value to Python value, filtering out placeholder values."""
        value = super().from_db_value(value, expression, connection)
        # Make defaults a list safely even if default is falsy/None
        if isinstance(self.default, list | tuple):
            defaults: list[str] = list(self.default)
        elif self.default:
            defaults = [self.default]
        else:
            defaults = []
        return [member for member in value if member not in defaults]


_GTIME_RE = re.compile(
    r"""
    ^
    (?P<year>\d{4})
    (?P<mon>\d{2})?
    (?P<day>\d{2})?
    (?P<hour>\d{2})?
    (?P<minute>\d{2})?
    (?P<second>\d{2})?
    (?:\.(?P<frac>\d+))?          # fractional seconds
    (?P<tz>Z|[+\-]\d{4})?         # 'Z' or ±HHMM
    $
    """,
    re.VERBOSE,
)


def parse_generalized_time(s: str) -> datetime:
    m = _GTIME_RE.match(s)
    if not m:
        raise ValueError(f'Invalid GeneralizedTime value: {s!r}')

    parts = {k: int(v) if v and k not in ['frac', 'tz'] else v for k, v in m.groupdict().items()}

    # Missing components default to minimal valid value (RFC says that is OK)
    dt = datetime(
        parts['year'],
        parts['mon'] or 1,
        parts['day'] or 1,
        parts['hour'] or 0,
        parts['minute'] or 0,
        parts['second'] or 0,
        int(float(f"0.{parts['frac']}") * 1_000_000) if parts['frac'] else 0,
    )

    tz = parts['tz']
    if tz == 'Z' or tz is None:
        dt = dt.replace(tzinfo=ZoneInfo('UTC'))
    else:
        sign = 1 if tz[0] == '+' else -1
        offset = (
            timedelta(
                hours=int(tz[1:3]),
                minutes=int(tz[3:5]),
            )
            * sign
        )
        dt = dt.replace(tzinfo=timezone(offset))
    return dt


def format_generalized_time(dt: date | datetime, include_tz: bool = False) -> str:
    if isinstance(dt, date) and not isinstance(dt, datetime):
        dt = datetime(year=dt.year, month=dt.month, day=dt.day)

    if dt.tzinfo is None:
        dt = dt.astimezone(ZoneInfo('UTC'))

    if include_tz:
        return dt.strftime('%Y%m%d%H%M%S%z')

    dt = dt.astimezone(ZoneInfo('UTC'))
    return dt.strftime('%Y%m%d%H%M%SZ')


class DateTimeField(LDAPField, django_fields.DateTimeField):
    default_date_format = '%Y-%m-%d %H:%M:%S %z'

    def __init__(self, *args, fmt: str | None = None, include_tz: bool = False, **kwargs):
        self.date_format = fmt or self.default_date_format
        self.include_tz = include_tz
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None

        dt = parse_generalized_time(value)
        return dt

    def get_prep_value(self, value: str | datetime) -> str | None:
        if value is None:
            return None

        if isinstance(value, str):
            value = datetime.strptime(value, self.date_format)

        if isinstance(value, datetime) and is_naive(value):
            value = value.replace(tzinfo=ZoneInfo('UTC'))

        value = format_generalized_time(value, include_tz=self.include_tz)
        return value


class DateField(DateTimeField, django_fields.DateField):
    default_date_format = '%Y-%m-%d'

    def __init__(self, *args, **kwargs):
        kwargs['include_tz'] = False
        super().__init__(*args, **kwargs)

    def from_db_value(self, *args, **kwargs):
        value: datetime = super().from_db_value(*args, **kwargs)
        if value is None:
            return None
        return value.date()

    def get_prep_value(self, value: str | date | datetime):
        if value is None:
            return None

        if isinstance(value, datetime):
            value = date(year=value.year, month=value.month, day=value.day)
        return super().get_prep_value(value)

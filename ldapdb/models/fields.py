import enum
import re
from collections.abc import Callable
from datetime import date, datetime, timedelta, timezone
from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable
from zoneinfo import ZoneInfo

from django.conf import settings
from django.core import checks
from django.core.exceptions import FieldError
from django.db.models import Lookup, fields as django_fields
from django.utils import timezone as dt_tz
from django.utils.dateparse import parse_datetime
from django.utils.timezone import is_naive
from passlib.exc import MissingBackendError
from passlib.handlers.argon2 import argon2
from passlib.hash import (
    ldap_pbkdf2_sha256,
    ldap_pbkdf2_sha512,
    ldap_salted_sha1,
    ldap_salted_sha256,
    ldap_salted_sha512,
    ldap_sha1,
)

from ldapdb.typing_compat import override
from ldapdb.validators import validate_dn

if TYPE_CHECKING:
    from ldapdb.backends.ldap.base import DatabaseWrapper
    from ldapdb.models import LDAPModel


class UpdateStrategy(str, enum.Enum):
    ADD_DELETE = 'ADD_DELETE'  # multi (MOD_ADD + MOD_DELETE)
    REPLACE = 'REPLACE'  # single (MOD_REPLACE)


@runtime_checkable
class RenderLookupProtocol(Protocol):
    def render_lookup(self, field_name: str, lookup_name: str, value: Any) -> str | None:
        """Convert the value passed to the QuerySet filter to an LDAP filter string."""


class LDAPField(django_fields.Field, RenderLookupProtocol):
    apply_default_on_empty: bool = False
    binary_field: bool = False
    multi_valued_field: bool = False
    ordering_rule: str | None = None
    read_only: bool = False
    update_strategy: UpdateStrategy = UpdateStrategy.REPLACE

    def __init__(
        self,
        *args,
        ordering_rule: str | None = None,
        hidden: bool = False,
        multi_valued_field: bool | None = None,
        update_strategy: UpdateStrategy | None = None,
        read_only: bool | None = None,
        **kwargs,
    ):
        """
        :param args:
        :param ordering_rule: Override the LDAP ordering rule for this field.
                              The fields provided by us already have the correct ordering rules set. (TODO)
        :param hidden: Hide this field from all autogenerated forms and admin interfaces.
        :param kwargs:
        """
        super().__init__(*args, **kwargs)

        if not kwargs.get('db_column'):
            raise ValueError(f'{self.__class__.__name__} needs an explicit db_column argument')

        if self.apply_default_on_empty and self.default:
            self.blank = True
            self.null = True

        if hidden is not None:
            self.hidden = hidden

        if multi_valued_field is not None:
            self.multi_valued_field = multi_valued_field

        if ordering_rule is not None:
            self.ordering_rule = ordering_rule

        if update_strategy is not None:
            self.update_strategy = update_strategy

        if read_only:
            self.blank = True
            self.editable = False
            self.null = True
            self.read_only = read_only

    def from_db_value(self, value, expression, connection):  # noqa: ARG002
        if value is None:
            if self.null:
                return value
            elif self.multi_valued_field:
                return []
            elif self.binary_field:
                return b'' if self.binary_field else ''

        if not isinstance(value, list | tuple):
            value = [value]

        if self.binary_field:
            return value if self.multi_valued_field else value[0]

        decoded_vals = [v.decode(connection.charset) if isinstance(v, bytes | bytearray) else v for v in value]
        return sorted(decoded_vals) if self.multi_valued_field else decoded_vals[0]

    def _check_default(self, **_kwargs):
        if self.default is None and not self.null:
            return [
                checks.Error(
                    'no default value or null=True specified',
                    hint=(
                        'Set a default value or null=True.'
                        'Make sure your LDAP server allows for nonexistent member attributes'
                    ),
                    obj=self,
                    id='ldapdb.E001',
                )
            ]
        return []

    def check(self, **kwargs):
        errors = super().check(**kwargs)
        if self.apply_default_on_empty:
            errors.extend(self._check_default(**kwargs))
        return errors

    def clean(self, value, model_instance):
        """
        Convert the value's type and run validation. Validation errors
        from to_python() and validate() are propagated. Return the correct
        value if no error is raised.

        Override the default clean() method from Django to let validators run on individual values of
        multi-valued fields.
        """
        value = self.to_python(value)
        self.validate(value, model_instance)

        # Normalize once for multi-valued fields, then run validators per-element
        if self.multi_valued_field and not isinstance(value, list | tuple):
            value = [value]

        if self.multi_valued_field and isinstance(value, list | tuple):
            for v in value:
                self.run_validators(v)
        else:
            self.run_validators(value)
        return value

    @override
    def get_db_prep_value(self, value: Any, connection: 'DatabaseWrapper', prepared: bool = False):
        """Prepare a value for DB interaction.

        Returns:
        - list(bytes) if not prepared
        - list(str) if prepared
        """

        if self.read_only:
            # Make sure this attribute is not included in write operations
            return []

        if prepared:
            return value

        if value is None:
            values: list[Any] = []
        else:
            if self.multi_valued_field and not isinstance(value, list | tuple):
                value = [value]
            values = value if self.multi_valued_field else [value]

        prepared_values = [self.get_prep_value(v) for v in values]

        # Remove duplicates, discard falsy prepared values, sort for stable order.
        unique_values = sorted({v for v in prepared_values if v})

        # If nothing remains and the field opts in, apply the default (supports str or list defaults)
        if not unique_values and self.apply_default_on_empty and self.default:
            default_values = self.default if isinstance(self.default, list | tuple) else [self.default]
            prepared_defaults = [self.get_prep_value(v) for v in default_values]
            unique_values = sorted({v for v in prepared_defaults if v})

        return unique_values

    def get_db_prep_save(self, value, connection: 'DatabaseWrapper'):
        values = self.get_db_prep_value(value, connection, prepared=False)
        if self.binary_field:
            # Already raw values; don't encode it twice.
            return values
        else:
            return [str(v).encode() for v in values]


class CharField(django_fields.CharField, LDAPField):
    def __init__(self, *args, **kwargs):
        defaults = {'max_length': 200}
        defaults.update(kwargs)
        super().__init__(*args, **defaults)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None if self.null else ''
        return value

    def to_python(self, value):
        if value is None:
            return value

        if self.multi_valued_field:
            # Only return a list if the input is already a list/tuple
            if isinstance(value, list | tuple):
                return [str(v) for v in value]
            # For scalar inputs, return a scalar to avoid nested lists during DB prep
            return str(value)
        return str(value)


TextField = CharField


class DistinguishedNameField(CharField):
    _allowed_lookups = {'exact', 'iexact', 'in', 'isnull'}
    default_validators = [validate_dn]

    def get_lookup(self, lookup_name: str) -> Lookup | None:
        if lookup_name not in self._allowed_lookups:
            raise FieldError(
                f'Lookup {lookup_name} is not supported for DN fields. '
                f'Either use an exact lookup filter({self.db_column}=...), '
                'or iterate over the results yourself.'
            )
        return super().get_lookup(lookup_name)


class BinaryField(django_fields.BinaryField, LDAPField):
    binary_field = True


class BooleanField(django_fields.BooleanField, LDAPField):
    """
    LDAP stores boolean values as 'TRUE' and 'FALSE'.
    Returns True if field is 'TRUE', None if field.null=True, and 'FALSE' otherwise.
    Default value is None if field.null=True but can be overridden by setting default=True or False.
    """

    def from_db_value(self, value, expression, connection):
        raw = super().from_db_value(value, expression, connection)
        if raw in (None, ''):
            return None
        return str(raw).upper() == 'TRUE'

    def get_prep_value(self, value):
        if value is None:
            return None
        return 'TRUE' if value else 'FALSE'


class EmailField(django_fields.EmailField, CharField):
    pass


class IntegerField(django_fields.IntegerField, LDAPField):
    def __init__(self, *args, **kwargs):
        kwargs['null'] = True
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return value
        return int(value)


class LDAPPasswordAlgorithm(str, enum.Enum):
    ARGON2 = 'ARGON2'
    PBKDF2_SHA256 = 'PBKDF2_SHA256'
    PBKDF2_SHA512 = 'PBKDF2_SHA512'
    SHA = 'SHA'
    SSHA = 'SSHA'
    SSHA256 = 'SSHA256'
    SSHA512 = 'SSHA512'
    PLAINTEXT = 'PLAINTEXT'  # should *never* be used, but we still want to support it


LDAP_PASSWORD_HANDLERS = {
    LDAPPasswordAlgorithm.SHA: ldap_sha1.hash,
    LDAPPasswordAlgorithm.SSHA: ldap_salted_sha1.hash,
    LDAPPasswordAlgorithm.SSHA256: ldap_salted_sha256.hash,
    LDAPPasswordAlgorithm.SSHA512: ldap_salted_sha512.hash,
    LDAPPasswordAlgorithm.PBKDF2_SHA256: ldap_pbkdf2_sha256.hash,
    LDAPPasswordAlgorithm.PBKDF2_SHA512: ldap_pbkdf2_sha512.hash,
    LDAPPasswordAlgorithm.ARGON2: lambda pw, **options: f'{{ARGON2}}{argon2.using(**options).hash(pw)}',
    LDAPPasswordAlgorithm.PLAINTEXT: lambda pw, **_: pw,
}


class PasswordField(CharField):
    """
    A field for storing LDAP passwords.
    It automatically hashes plain-text values on save but preserves existing hashes.
    """

    def __init__(
        self,
        *args,
        algorithm: str | LDAPPasswordAlgorithm,
        handler: Callable | None = None,
        handler_opts: dict | None = None,
        **kwargs,
    ):
        self.algorithm = algorithm
        self.handler = handler
        self.handler_opts = handler_opts or {}
        super().__init__(*args, **kwargs)

    def _check_installed_argon2(self) -> list[checks.Error]:
        try:
            argon2.get_backend()
        except MissingBackendError:
            return [
                checks.Error(
                    'No argon2 backend installed. '
                    'Install it with `pip install django-ldapdb2[argon2] # or directly via argon2-cffi`.',
                    hint='See https://argon2-cffi.readthedocs.io/en/stable/installation.html',
                    obj=self,
                    id='ldapdb.E002',
                )
            ]
        return []

    def check(self, **kwargs):
        errors = super().check(**kwargs)
        if str(self.algorithm) == LDAPPasswordAlgorithm.ARGON2.value:
            errors.extend(self._check_installed_argon2())
        return errors

    @staticmethod
    def generate_password_hash(password: str, algorithm: LDAPPasswordAlgorithm | str, **options) -> str:
        handler = LDAP_PASSWORD_HANDLERS.get(algorithm)
        if not handler:
            raise ValueError(
                f'No handler found for algorithm: {algorithm}. '
                f'Supported algorithms: {", ".join(LDAP_PASSWORD_HANDLERS.keys())}.'
                f'Or supply your own handler via the `handler` argument.'
            )

        # Note: Support for passing settings via .hash() will be removed in Passlib 2.0.
        # Since we're not sure about the future of passlib, we'll keep it as-is for now.
        return handler(password, **options)

    def _hash_if_needed(self, value: str) -> str:
        if value and not value.startswith('{'):
            if self.handler:
                return self.handler(value, **self.handler_opts)
            return self.generate_password_hash(value, self.algorithm, **self.handler_opts)
        return value

    @override
    def pre_save(self, model_instance: 'LDAPModel', add: bool):
        """
        Called just before the field value is sent to the database.
        We use this to hash the plaintext and update the instance attribute.
        """
        value = getattr(model_instance, self.attname)

        hashed_value = self._hash_if_needed(value)
        if hashed_value != value:
            setattr(model_instance, self.attname, hashed_value)
        return hashed_value

    def get_db_prep_save(self, value: str, connection: 'DatabaseWrapper'):
        value = self._hash_if_needed(value)
        return super().get_db_prep_save(value, connection)


class MemberField(DistinguishedNameField):
    # TODO: Maybe allow setting a QuerySet as a default?
    multi_valued_field = True
    update_strategy = UpdateStrategy.ADD_DELETE
    apply_default_on_empty = True

    # No custom get_db_prep_value needed; base class handles defaults.
    def from_db_value(self, value, expression, connection):
        """Convert DB value to Python value, filtering out placeholder values."""
        value = super().from_db_value(value, expression, connection)
        # Make defaults a list safely even if default is falsy/None
        if isinstance(self.default, list | tuple):
            defaults: list[str] = list(self.default)
        elif self.default:
            defaults = [self.default]
        else:
            defaults = []
        return [member for member in value if member not in defaults]


_GTIME_RE = re.compile(
    r"""
    ^
    (?P<year>\d{4})
    (?P<mon>\d{2})?
    (?P<day>\d{2})?
    (?P<hour>\d{2})?
    (?P<minute>\d{2})?
    (?P<second>\d{2})?
    (?:\.(?P<frac>\d+))?          # fractional seconds
    (?P<tz>Z|[+\-]\d{4})?         # 'Z' or Â±HHMM
    $
    """,
    re.VERBOSE,
)


def parse_generalized_time(s: str) -> datetime:
    m = _GTIME_RE.match(s)
    if not m:
        raise ValueError(f'Invalid GeneralizedTime value: {s!r}')

    parts = {k: int(v) if v and k not in ['frac', 'tz'] else v for k, v in m.groupdict().items()}

    # Missing components default to minimal valid value (RFC says that is OK)
    dt = datetime(
        parts['year'],
        parts['mon'] or 1,
        parts['day'] or 1,
        parts['hour'] or 0,
        parts['minute'] or 0,
        parts['second'] or 0,
        int(float(f'0.{parts["frac"]}') * 1_000_000) if parts['frac'] else 0,
    )

    tz = parts['tz']
    if tz == 'Z' or tz is None:
        dt = dt.replace(tzinfo=ZoneInfo('UTC'))
    else:
        sign = 1 if tz[0] == '+' else -1
        offset = (
            timedelta(
                hours=int(tz[1:3]),
                minutes=int(tz[3:5]),
            )
            * sign
        )
        dt = dt.replace(tzinfo=timezone(offset))
    return dt


def format_generalized_time(dt: date | datetime, include_tz: bool = False) -> str:
    if isinstance(dt, date) and not isinstance(dt, datetime):
        dt = datetime(year=dt.year, month=dt.month, day=dt.day, tzinfo=ZoneInfo('UTC'))

    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=ZoneInfo('UTC'))

    if include_tz:
        return dt.strftime('%Y%m%d%H%M%S%z')

    dt = dt.astimezone(ZoneInfo('UTC'))
    return dt.strftime('%Y%m%d%H%M%SZ')


class DateTimeField(LDAPField, django_fields.DateTimeField):
    default_date_format = '%Y-%m-%d %H:%M:%S %z'

    def __init__(self, *args, fmt: str | None = None, include_tz: bool = False, **kwargs):
        self.date_format = fmt or self.default_date_format
        self.include_tz = include_tz
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        value = super().from_db_value(value, expression, connection)
        if value is None:
            return None

        dt = parse_generalized_time(value)

        if not settings.USE_TZ:
            dt = dt_tz.make_naive(dt, dt_tz.get_default_timezone())

        return dt

    def get_prep_value(self, value: str | datetime) -> str | None:
        if value is None:
            return None

        if isinstance(value, str):
            # Use Django's parser which handles ISO strings with/without TZ instead of strict strptime(..., '%z')
            parsed = parse_datetime(value)
            value = parsed if parsed is not None else datetime.strptime(value, self.date_format)

        if isinstance(value, datetime) and is_naive(value):
            value = dt_tz.make_aware(value, dt_tz.get_current_timezone())

        value = format_generalized_time(value, include_tz=self.include_tz)
        return value


class DateField(LDAPField, django_fields.DateField):
    """
    LDAP-specific DateField that handles LDAP GeneralizedTime strings and normalizes to date objects.
    We keep this seperate from DateTimeField because some integration check the field type via isinstance().
    """

    def from_db_value(self, *args, **kwargs) -> date | None:
        value: str = super().from_db_value(*args, **kwargs)
        if value is None:
            return None

        dt = parse_generalized_time(value)
        return dt.date()

    def get_prep_value(self, value: str | date | datetime) -> str | None:
        if value is None:
            return None

        # Ensure we have a date object
        if isinstance(value, str):
            value = self.to_python(value)
        if isinstance(value, datetime):
            value = value.date()

        return format_generalized_time(value, include_tz=False)
